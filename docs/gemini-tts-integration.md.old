# Há»‡ Thá»‘ng Gemini AI Content Processing & TTS Integration

## ğŸ“‹ Tá»•ng Quan

Há»‡ thá»‘ng tá»± Ä‘á»™ng xá»­ lÃ½ ná»™i dung chÆ°Æ¡ng truyá»‡n (dá»‹ch hoáº·c tÃ³m táº¯t) báº±ng Gemini AI vÃ  chuyá»ƒn Ä‘á»•i sang audio TTS, Ä‘Æ°á»£c tÃ­ch há»£p sÃ¢u vÃ o mÃ n hÃ¬nh Ä‘á»c truyá»‡n. Há»‡ thá»‘ng hoáº¡t Ä‘á»™ng theo 3 modes:

1. **Normal Mode**: Hiá»ƒn thá»‹ ná»™i dung gá»‘c HTML
2. **Translate Mode**: Tá»± Ä‘á»™ng dá»‹ch ná»™i dung + TTS audio
3. **Summary Mode**: Tá»± Ä‘á»™ng tÃ³m táº¯t + TTS audio

**TÃ­nh nÄƒng chÃ­nh:**
- âœ… Cache ná»™i dung Ä‘Ã£ xá»­ lÃ½ trong SQLite database
- âœ… Prefetch tá»± Ä‘á»™ng 10 chÆ°Æ¡ng tiáº¿p theo trong background
- âœ… TTS on-demand cho táº¥t cáº£ cÃ¡c modes
- âœ… Debouncing 500ms khi chuyá»ƒn Ä‘á»•i mode
- âœ… Migration tá»± Ä‘á»™ng tá»« MMKV sang SQLite

---

## ğŸ—ï¸ Kiáº¿n TrÃºc Tá»•ng Thá»ƒ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Reading Screen (/app/reading/index.tsx)  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  useReadingChapter(bookId)                          â”‚    â”‚
â”‚  â”‚  - Quáº£n lÃ½ state chapter hiá»‡n táº¡i                   â”‚    â”‚
â”‚  â”‚  - PhÃ¡t hiá»‡n mode (Normal/Translate/Summary)        â”‚    â”‚
â”‚  â”‚  - Debouncing 500ms khi Ä‘á»•i mode                    â”‚    â”‚
â”‚  â”‚  - Gá»i useContentProcessor cho translate/summary    â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                     â”‚                                        â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚         â–¼                      â–¼              â–¼            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Normal Mode â”‚      â”‚ Translate    â”‚  â”‚ Summary      â”‚  â”‚
â”‚  â”‚ Load HTML   â”‚      â”‚ Mode         â”‚  â”‚ Mode         â”‚  â”‚
â”‚  â”‚ Show Raw    â”‚      â”‚ SQLite Cache â”‚  â”‚ SQLite Cache â”‚  â”‚
â”‚  â”‚ Content     â”‚      â”‚ + Gemini API â”‚  â”‚ + Gemini API â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                  â”‚           â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                       â–¼                     â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚                    â”‚ TTS Button (On-demand)   â”‚            â”‚
â”‚                    â”‚ ttsService.generateTTS() â”‚            â”‚
â”‚                    â”‚ - Split content          â”‚            â”‚
â”‚                    â”‚ - Call Capcut API        â”‚            â”‚
â”‚                    â”‚ - Save to DB + Files     â”‚            â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                       â”‚                     â”‚
â”‚                                       â–¼                     â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚                    â”‚ ReadingAudioControl      â”‚            â”‚
â”‚                    â”‚ - Load from database     â”‚            â”‚
â”‚                    â”‚ - Queue track player     â”‚            â”‚
â”‚                    â”‚ - Auto-play              â”‚            â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Background Services:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ usePrefetch Hook     â”‚
â”‚ - Prefetch 10 ch     â”‚
â”‚ - Max 2 concurrent   â”‚
â”‚ - 2s delay between   â”‚
â”‚ - Skip if cached     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ Database Schema

### SQLite Tables

**1. processed_chapters**
```sql
CREATE TABLE processed_chapters (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  book_id TEXT NOT NULL,
  chapter_number INTEGER NOT NULL,
  mode TEXT NOT NULL CHECK(mode IN ('translate', 'summary')),
  content TEXT NOT NULL,
  content_hash TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  UNIQUE(book_id, chapter_number, mode)
);
```

**2. tts_audio_cache**
```sql
CREATE TABLE tts_audio_cache (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  book_id TEXT NOT NULL,
  chapter_number INTEGER NOT NULL,
  mode TEXT NOT NULL CHECK(mode IN ('normal', 'translate', 'summary')),
  sentence_index INTEGER NOT NULL,
  sentence_text TEXT NOT NULL,
  file_path TEXT NOT NULL,
  file_size INTEGER,
  duration REAL,
  created_at INTEGER NOT NULL,
  UNIQUE(book_id, chapter_number, mode, sentence_index)
);
```

**3. prefetch_queue**
```sql
CREATE TABLE prefetch_queue (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  book_id TEXT NOT NULL,
  chapter_number INTEGER NOT NULL,
  mode TEXT NOT NULL,
  status TEXT CHECK(status IN ('pending', 'processing', 'completed', 'failed')),
  priority INTEGER DEFAULT 0,
  error_message TEXT,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  UNIQUE(book_id, chapter_number, mode)
);
```

**File Structure:**
```
tts_audio/
  {bookId}/
    {chapter}/
      normal/
        sentence_0.mp3
        sentence_1.mp3
      translate/
        sentence_0.mp3
        sentence_1.mp3
      summary/
        sentence_0.mp3
        sentence_1.mp3
```

---

## ğŸ“¦ CÃ¡c Service & Hook ChÃ­nh

### 1. **Database Service** (`/services/database-service.ts`)

**Vai trÃ²**: Quáº£n lÃ½ SQLite database cho cache vÃ  prefetch

**Key Methods**:

```typescript
// Processed Content
async getProcessedChapter(bookId, chapter, mode): Promise<ProcessedChapter | null>
async saveProcessedChapter(bookId, chapter, mode, content, hash?)
async deleteProcessedChapter(bookId, chapter, mode?)
async clearBookCache(bookId, mode?)
async clearAllCache()

// TTS Audio
async getTTSAudios(bookId, chapter, mode): Promise<TTSAudio[]>
async saveTTSAudio(bookId, chapter, mode, sentenceIndex, text, path, size?)
async getTTSCount(bookId, chapter, mode): Promise<number>
async clearTTSCache(bookId, chapter?, mode?)

// Prefetch Queue
async addToPrefetchQueue(bookId, chapter, mode, priority)
async getPendingPrefetchTasks(limit): Promise<PrefetchTask[]>
async updatePrefetchStatus(taskId, status, errorMsg?)
async clearPrefetchQueue(bookId?, mode?)

// Stats
async getCacheStats(): Promise<{ totalChapters, totalTTS, totalPrefetchPending }>
async getBookCacheStats(bookId): Promise<{ chapters, ttsAudios }>
```

**Transaction Support**:
```typescript
// All write operations use transactions for data integrity
await this.db.runAsync('BEGIN TRANSACTION')
try {
  await this.db.runAsync('INSERT INTO ...')
  await this.db.runAsync('COMMIT')
} catch (error) {
  await this.db.runAsync('ROLLBACK')
  throw error
}
```

---

### 2. **Content Processor Hook** (`/hooks/use-content-processor.ts`)

**Vai trÃ²**: Xá»­ lÃ½ ná»™i dung cho translate vÃ  summary modes

**Flow hoáº¡t Ä‘á»™ng**:

```typescript
processContent(bookId, chapter, rawContent, mode)
  â†“
  1. Check SQLite cache: dbService.getProcessedChapter()
     â”œâ”€ CÃ³ cache â†’ Return ngay
     â””â”€ KhÃ´ng cÃ³ â†’ Continue
  â†“
  2. Call Gemini API:
     â”œâ”€ mode='translate' â†’ geminiService.translateChapter()
     â”œâ”€ mode='summary' â†’ geminiService.summarizeChapter()
     â””â”€ Error â†’ Return null
  â†“
  3. Save to database: dbService.saveProcessedChapter()
  â†“
  4. Return processed content
```

**Cache Strategy**:
- âœ… Normal mode: KhÃ´ng cache (hiá»ƒn thá»‹ HTML gá»‘c)
- âœ… Translate/Summary: Cache trong SQLite
- âœ… Content hash Ä‘á»ƒ detect changes
- âœ… Auto-refresh náº¿u source content thay Ä‘á»•i

---

### 3. **Prefetch Hook** (`/hooks/use-prefetch.ts`)

**Vai trÃ²**: Tá»± Ä‘á»™ng táº¡o ná»™i dung cho 10 chÆ°Æ¡ng tiáº¿p theo trong background

**Configuration**:
```typescript
const PREFETCH_AHEAD = 10        // Sá»‘ chÆ°Æ¡ng prefetch
const MAX_CONCURRENT = 2         // Max concurrent API calls
const DELAY_BETWEEN_REQUESTS = 2000  // 2s delay giá»¯a cÃ¡c request
```

**Flow hoáº¡t Ä‘á»™ng**:

```typescript
usePrefetch(bookId, currentChapter, mode, isActive)
  â†“
  1. Calculate prefetch range: [current+1 ... current+10]
  â†“
  2. Filter out cached chapters
  â†“
  3. Add to prefetch queue in database
  â†“
  4. Process queue vá»›i rate limiting:
     - Max 2 concurrent
     - 2s delay between batches
     - Abort náº¿u user inactive
  â†“
  5. For each chapter:
     - Load raw content
     - Call processContent()
     - Update queue status
```

**Abort Strategy**:
```typescript
useEffect(() => {
  const abortController = new AbortController()
  
  // Process prefetch queue...
  
  return () => {
    abortController.abort() // Cancel khi unmount hoáº·c dependencies change
  }
}, [bookId, currentChapter, mode, isActive])
```

---

### 4. **Gemini Service** (`/services/gemini-service.ts`)

**API Configuration**:
```typescript
// Dynamic model selection tá»« settings
const getGeminiModel = () => {
  return MMKVStorage.get(MMKVKeys.GEMINI_MODEL) || 'gemini-2.0-flash-exp'
}

const getGeminiApiUrl = () => {
  const apiKey = MMKVStorage.get(MMKVKeys.GEMINI_API_KEY)
  const model = getGeminiModel()
  return `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`
}
```

**Default Prompts**:
```typescript
// Summary Prompt
DEFAULT_SUMMARY_PROMPT = `
HÃ£y tÃ³m táº¯t ná»™i dung chÆ°Æ¡ng truyá»‡n sau má»™t cÃ¡ch ngáº¯n gá»n nháº¥t cÃ³ thá»ƒ, 
chá»‰ giá»¯ láº¡i cÃ¡c sá»± kiá»‡n vÃ  thÃ´ng tin quan trá»ng.
Káº¿t quáº£ tÃ³m táº¯t nÃªn ngáº¯n gá»n, dá»… hiá»ƒu vÃ  chá»‰ gá»“m tá»« 3-5 cÃ¢u.
`

// Translate Prompt
DEFAULT_TRANSLATE_PROMPT = `
HÃ£y dá»‹ch ná»™i dung sau sang tiáº¿ng Viá»‡t má»™t cÃ¡ch tá»± nhiÃªn vÃ  dá»… hiá»ƒu.
Giá»¯ nguyÃªn Ã½ nghÄ©a vÃ  giá»ng vÄƒn cá»§a tÃ¡c giáº£.
KhÃ´ng thÃªm bÃ¬nh luáº­n hay giáº£i thÃ­ch.
`
```

**Translation Logic**:
```typescript
export const translateChapter = async (chapterContent: string): Promise<string> => {
  const apiKey = MMKVStorage.get(MMKVKeys.GEMINI_API_KEY)
  const translatePrompt = MMKVStorage.get(MMKVKeys.GEMINI_TRANSLATE_PROMPT) 
    || DEFAULT_TRANSLATE_PROMPT
  
  if (!apiKey) throw new Error('Thiáº¿u Gemini API Key')
  if (!chapterContent) throw new Error('Ná»™i dung chÆ°Æ¡ng trá»‘ng')
  
  const requestBody = {
    contents: [{
      parts: [{
        text: `${translatePrompt}\n\nNá»™i dung:\n${chapterContent}`
      }]
    }]
  }
  
  const response = await fetch(getGeminiApiUrl(), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody)
  })
  
  const data = await response.json()
  return data.candidates[0].content.parts[0].text
}

export const summarizeChapter = async (chapterContent: string): Promise<string> => {
  const apiKey = MMKVStorage.get(MMKVKeys.GEMINI_API_KEY)
  const summaryPrompt = MMKVStorage.get(MMKVKeys.GEMINI_SUMMARY_PROMPT) 
    || DEFAULT_SUMMARY_PROMPT
  
  if (!apiKey) throw new Error('Thiáº¿u Gemini API Key')
  if (!chapterContent) throw new Error('Ná»™i dung chÆ°Æ¡ng trá»‘ng')
  
  const requestBody = {
    contents: [{
      parts: [{
        text: `${summaryPrompt}\n\nNá»™i dung chÆ°Æ¡ng:\n${chapterContent}`
      }]
    }]
  }
  
  const response = await fetch(getGeminiApiUrl(), {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(requestBody)
  })
  
  const data = await response.json()
  return data.candidates[0].content.parts[0].text
}
```

**Settings Dependencies**:
- `GEMINI_API_KEY`: API key tá»« Google AI Studio
- `GEMINI_MODEL`: Model name (default: `gemini-2.0-flash-exp`)
- `GEMINI_SUMMARY_PROMPT`: Custom prompt cho summarization
- `GEMINI_TRANSLATE_PROMPT`: Custom prompt cho translation

---

### 5. **TTS Service** (`/services/tts-service.ts`)

**Vai trÃ²**: Quáº£n lÃ½ TTS audio generation vÃ  database storage

**Key Methods**:

```typescript
// Generate TTS audio for content
async generateTTS(
  bookId: string,
  chapter: number,
  mode: ReadingMode,
  content: string
): Promise<void> {
  // 1. Split content into sentences
  const sentences = breakSummaryIntoLines(content)
  
  // 2. Create directory structure
  const dir = `tts_audio/${bookId}/${chapter}/${mode}`
  
  // 3. Generate audio for each sentence
  for (let i = 0; i < sentences.length; i++) {
    const filePath = `${dir}/sentence_${i}.mp3`
    await convertTTSCapcut(sentences[i], filePath)
    
    // Save to database
    await dbService.saveTTSAudio(
      bookId, chapter, mode, i, 
      sentences[i], filePath
    )
  }
  
  // 4. Emit event for audio player
  emitExistingTTS(bookId, chapter, mode)
}

// Load existing TTS from database
async loadExistingTTS(
  bookId: string,
  chapter: number,
  mode: ReadingMode
): Promise<TTSAudio[]> {
  return await dbService.getTTSAudios(bookId, chapter, mode)
}

// Clear TTS cache
async clearTTS(
  bookId: string,
  chapter?: number,
  mode?: ReadingMode
): Promise<void> {
  await dbService.clearTTSCache(bookId, chapter, mode)
  
  // Delete files from filesystem
  const dir = chapter && mode 
    ? `tts_audio/${bookId}/${chapter}/${mode}`
    : `tts_audio/${bookId}`
  // Delete directory recursively...
}
```

**Event System**:
```typescript
// Emit khi cÃ³ TTS audios má»›i
DeviceEventEmitter.emit('TTS_READY', {
  bookId,
  chapter,
  mode,
  audios: TTSAudio[]
})
```

---

### 6. **ReadingAudioControl** (`/components/reading/reading-audio-control.tsx`)

**Vai trÃ²**: PhÃ¡t audio TTS tá»« database

**Props**:
```typescript
interface Props {
  chapter: number      // Sá»‘ chapter
  bookId: string       // ID book
  mode: ReadingMode    // normal | translate | summary
  bookId: string       // ID book
  content: string      // Ná»™i dung summary (HTML Ä‘Ã£ Ä‘Æ°á»£c xá»­ lÃ½)
}
```

**Lifecycle**:
```typescript
useEffect(() => {
  // On mount hoáº·c khi chapter/content thay Ä‘á»•i
  startGenerateAudio(content, bookId, chapter)
  
  return () => {
    // Cleanup: Stop TTS khi unmount
    stopGenerateAudio()
  }
}, [chapter, bookId, content])
```

**Render**:
```tsx
<View style={styles.viewContainer}>
  <PlayAudioControl />  {/* UI controls: play/pause/next/prev */}
</View>
```

**Position**: Fixed á»Ÿ bottom-left mÃ n hÃ¬nh, cÃ³ safe area insets

---

### 6. **useTtsAudio Hook** (`/hooks/use-tts-audio.ts`)

**Vai trÃ²**: Xá»­ lÃ½ toÃ n bá»™ logic TTS - chia text, gá»i API, queue tracks

**Main Functions**:

#### 6.1 **startGenerateAudio**
```typescript
const startGenerateAudio = async (content: string, bookId: string, chapter: number) => {
  try {
    // 1. Tiá»n xá»­ lÃ½ content
    const cleanContent = content
      .replace(/<[^><]*>/g, ' ')  // Remove HTML tags
      .replace(/\s+/g, ' ')        // Normalize whitespace
      .trim()
    
    // 2. Chia thÃ nh cÃ¡c cÃ¢u ngáº¯n
    const sentences = breakSummaryIntoLines(cleanContent)
    if (sentences.length === 0) return
    
    // 3. Reset track player
    await trackPlayerService.reset()
    
    // 4. Gá»i Capcut TTS API
    await convertTTSCapcut(sentences, `${bookId}_${chapter}`)
    
    return true
  } catch (error) {
    Alert.alert('Lá»—i TTS', 'KhÃ´ng thá»ƒ táº¡o audio tá»« ná»™i dung tÃ³m táº¯t')
    return false
  }
}
```

#### 6.2 **Event Listener: tts_audio_ready**
```typescript
DeviceEventEmitter.addListener('tts_audio_ready', async (data) => {
  // Data structure:
  // {
  //   filePath: string     // Path to audio file
  //   audioTaskId: string  // Unique task ID
  //   index: number        // Sentence index
  // }
  
  // 1. Create track object
  const track = {
    id: data.audioTaskId,
    url: data.filePath.startsWith('file://') 
      ? data.filePath 
      : `file://${data.filePath}`,
    title: data.audioTaskId,
    artist: 'TTS Capcut'
  }
  
  // 2. Add to queue
  await trackPlayerService.addTracks([track])
  
  // 3. Auto-play first track (index === 3 lÃ  heuristic)
  if (data.index === 3) {
    await trackPlayerService.skipToTrack(0)
    await trackPlayerService.setRate(1.2)  // Speed up 1.2x
    await trackPlayerService.play()
  }
})
```

**Táº¡i sao `index === 3`?**
- Capcut TTS xá»­ lÃ½ parallel nhiá»u cÃ¢u cÃ¹ng lÃºc
- Äá»£i Ã­t nháº¥t 3-4 tracks sáºµn sÃ ng Ä‘á»ƒ Ä‘áº£m báº£o playback mÆ°á»£t
- TrÃ¡nh buffering khi chuyá»ƒn track

---

### 7. **Capcut TTS Service** (`/services/convert-tts.ts`)

**Configuration**:
```typescript
const CAPCUT_TOKEN = MMKVStorage.get(MMKVKeys.CAPCUT_TOKEN)
const CAPCUT_WS_URL = MMKVStorage.get(MMKVKeys.CAPCUT_WS_URL)
```

**Main Function**:
```typescript
export const convertTTSCapcut = async (
  texts: string[],
  taskPrefix: string
): Promise<void> => {
  // 1. Khá»Ÿi táº¡o WebSocket connection
  const ws = new WebSocket(CAPCUT_WS_URL)
  
  // 2. Xá»­ lÃ½ tá»«ng text trong array
  for (let i = 0; i < texts.length; i++) {
    const text = preprocessSentence(texts[i])
    const audioTaskId = `${taskPrefix}_${i}`
    
    // 3. Check cache trÆ°á»›c
    const cachedPath = getCachedAudioPath(text)
    if (cachedPath && await fileExists(cachedPath)) {
      // Emit event ngay láº­p tá»©c
      DeviceEventEmitter.emit('tts_audio_ready', {
        filePath: cachedPath,
        audioTaskId,
        index: i
      })
      continue
    }
    
    // 4. Gá»­i request qua WebSocket
    ws.send(JSON.stringify({
      type: 'tts_request',
      text,
      token: CAPCUT_TOKEN,
      taskId: audioTaskId
    }))
    
    // 5. Nháº­n response vÃ  lÆ°u file
    ws.onmessage = async (event) => {
      const { audioData, taskId } = JSON.parse(event.data)
      const filePath = await saveAudioFile(audioData, taskId)
      
      // Cache file path
      setCachedAudioPath(text, filePath)
      
      // Emit event
      DeviceEventEmitter.emit('tts_audio_ready', {
        filePath,
        audioTaskId: taskId,
        index: i
      })
    }
  }
}
```

**Cache Strategy**:
- **File storage**: `DocumentDirectory/tts_audio/`
- **MMKV mapping**: `{hash(text) â†’ filePath}`
- **Hash function**: Simple 32-bit hash tá»« text content

---

## ğŸ”„ Luá»“ng Hoáº¡t Äá»™ng Chi Tiáº¿t

### Scenario 1: Äá»c Chapter á»Ÿ Summary Mode (Láº§n Ä‘áº§u)

```
User tá»›i chapter 5 á»Ÿ summary mode
    â†“
useReadingChapter detect isSummaryMode = true
    â†“
Emit EVENT_START_LOADING_CHAPTER
    â†“
getBookChapterContent(bookId, 5)
    â†“
Load file: books/{bookId}/chapters/chapter_5.json
    â†“
Emit EVENT_START_GENERATE_SUMMARY
    â†“
useSummary(bookId, 5, content)
    â”œâ”€ getCachedSummary(bookId, 5) â†’ null
    â”œâ”€ Call Gemini API with content
    â”œâ”€ Receive summary text
    â””â”€ setCachedSummary(bookId, 5, summary)
    â†“
Set chapter state: { content: summary, summary: true }
    â†“
Emit EVENT_END_GENERATE_SUMMARY
    â†“
ReadingAudioControl mounts
    â†“
useTtsAudio.startGenerateAudio(summary, bookId, 5)
    â”œâ”€ Clean HTML tags
    â”œâ”€ breakSummaryIntoLines(summary) â†’ ["CÃ¢u 1.", "CÃ¢u 2.", ...]
    â”œâ”€ Reset track player
    â””â”€ convertTTSCapcut(sentences, "bookId_5")
        â”œâ”€ For each sentence:
        â”‚   â”œâ”€ Check cache â†’ null
        â”‚   â”œâ”€ Send WebSocket request
        â”‚   â”œâ”€ Receive audio data
        â”‚   â”œâ”€ Save to file
        â”‚   â”œâ”€ Cache file path
        â”‚   â””â”€ Emit 'tts_audio_ready'
        â””â”€ useTtsAudio listener receives events
            â”œâ”€ Add tracks to queue
            â””â”€ Auto-play when index === 3
```

**Thá»i gian Æ°á»›c tÃ­nh**:
- Load chapter content: ~100-200ms
- Gemini API summarize: ~2-5s (depending on content length)
- TTS for 5 sentences: ~1-2s per sentence
- **Total**: ~10-15 giÃ¢y cho láº§n Ä‘áº§u

---

### Scenario 2: Äá»c Chapter á»Ÿ Summary Mode (ÄÃ£ cache)

```
User quay láº¡i chapter 5 á»Ÿ summary mode
    â†“
useSummary(bookId, 5, content)
    â”œâ”€ getCachedSummary(bookId, 5) â†’ "Summary text Ä‘Ã£ lÆ°u"
    â””â”€ Return ngay láº­p tá»©c
    â†“
Set chapter state: { content: summary, summary: true }
    â†“
ReadingAudioControl mounts
    â†“
useTtsAudio.startGenerateAudio(summary, bookId, 5)
    â”œâ”€ breakSummaryIntoLines(summary)
    â””â”€ convertTTSCapcut(sentences, "bookId_5")
        â””â”€ For each sentence:
            â”œâ”€ getCachedAudioPath(text) â†’ "/path/to/cached.mp3"
            â””â”€ Emit 'tts_audio_ready' ngay láº­p tá»©c
    â†“
Auto-play audio
```

**Thá»i gian Æ°á»›c tÃ­nh**: ~500ms (gáº§n nhÆ° tá»©c thÃ¬)

---

### Scenario 3: Tá»± Äá»™ng Generate Summary & TTS Cho ToÃ n Bá»™ Book

MÃ n hÃ¬nh: `/app/generate-summary-tts/index.tsx`  
Component: `AutoGenerateController`

```
User click "Táº¡o tÃ³m táº¯t vÃ  audio"
    â†“
Alert xÃ¡c nháº­n: "Sáº½ xá»­ lÃ½ ${totalChapters} chÆ°Æ¡ng"
    â†“
User confirm â†’ startGenerate()
    â†“
For chapter = 1 to totalChapters:
    â”œâ”€ setState({ isRunning: true, currentChapter: chapter })
    â”œâ”€ loadChapterContent(chapter)
    â”œâ”€ startSummary(bookId, chapter, content)
    â”‚   â”œâ”€ Check cache â†’ Skip if exists
    â”‚   â””â”€ Call Gemini â†’ Save cache
    â”œâ”€ breakSummaryIntoLines(summary).slice(0, 5)  â† Giá»›i háº¡n 5 cÃ¢u
    â”œâ”€ startGenerateAudio(summary, bookId, chapter)
    â”‚   â””â”€ convertTTSCapcut â†’ Save all audio files
    â””â”€ Continue to next chapter
    â†“
Alert: "HoÃ n thÃ nh"
```

**Progress Tracking**:
- UI hiá»ƒn thá»‹ progress bar: `currentChapter / totalChapters`
- Stats: HoÃ n thÃ nh, ChÆ°Æ¡ng hiá»‡n táº¡i, Äang load
- User cÃ³ thá»ƒ "Dá»«ng" báº¥t cá»© lÃºc nÃ o (set `refStopProcess.current = true`)

**LÆ°u Ã½**:
- Chá»‰ láº¥y **5 cÃ¢u Ä‘áº§u** cá»§a summary Ä‘á»ƒ TTS (tiáº¿t kiá»‡m thá»i gian & storage)
- Process tuáº§n tá»± (khÃ´ng parallel) Ä‘á»ƒ trÃ¡nh rate limit API

---

## ğŸ“‚ Há»‡ Thá»‘ng Cache

### 1. **Summary Cache** (`utils/summary-cache.ts`)

**Storage**: MMKV vá»›i encryption  
**ID**: `'summary-cache'`  
**Encryption Key**: `'chapter-summaries'`

**API**:
```typescript
getCachedSummary(bookId, chapterNumber)      // Get
setCachedSummary(bookId, chapterNumber, text) // Set
deleteCachedSummary(bookId, chapterNumber)   // Delete single
clearBookSummaryCache(bookId)                // Delete all of book
getSummaryCountForBook(bookId)               // Count
```

**Key Format**: `summary_{bookId}_{chapterNumber}`

**Example**:
```typescript
setCachedSummary('book123', 5, 'Summary text...')
// Saved as: summary_book123_5
```

---

### 2. **TTS Audio Cache** (`utils/tts-cache.ts`)

**Storage**: 
- File: `DocumentDirectory/tts_audio/cache_{hash}.mp3`
- MMKV: Mapping `{hash â†’ filePath}`

**ID**: `'tts-cache'`  
**Encryption Key**: `'tts-audio-files'`

**API**:
```typescript
getCachedAudioPath(text)        // Get file path
setCachedAudioPath(text, path)  // Set mapping
deleteCachedAudioPath(text)     // Delete mapping
getTTSCacheStats()              // Get stats
```

**Hash Function**:
```typescript
const createSimpleHash = (text: string): string => {
  let hash = 0
  for (let i = 0; i < text.length; i++) {
    const char = text.charCodeAt(i)
    hash = (hash << 5) - hash + char
    hash &= hash // Convert to 32bit integer
  }
  return `cache_${Math.abs(hash).toString(36)}`
}
```

**Cache Stats**:
```typescript
const stats = await getTTSCacheStats()
// {
//   totalFiles: 150,
//   totalSize: 12500000,  // bytes
//   cacheKeys: 150
// }
```

---

### 3. **Cache Cleanup** (`utils/cache-manager.ts`)

**API**:
```typescript
clearBookCache(bookId)  // XÃ³a toÃ n bá»™ summary + audio cá»§a 1 book
```

**Implementation**:
```typescript
export const clearBookCache = async (bookId: string): Promise<void> => {
  // 1. Clear summary cache
  clearBookSummaryCache(bookId)
  
  // 2. Clear audio files & MMKV mapping
  // âš ï¸ Hiá»‡n táº¡i chÆ°a implement pháº§n nÃ y
  // TODO: Delete files matching pattern bookId_*
}
```

**Váº¥n Ä‘á» hiá»‡n táº¡i**:
- Chá»‰ clear Ä‘Æ°á»£c MMKV summary cache
- Audio files váº«n cÃ²n láº¡i trÃªn disk
- Cáº§n thÃªm logic Ä‘á»ƒ scan & delete files based on bookId

---

## ğŸ› ï¸ Text Processing Utilities

### 1. **breakSummaryIntoLines** (`utils/string-helpers.ts`)

**Má»¥c Ä‘Ã­ch**: Chia summary thÃ nh cÃ¡c cÃ¢u ngáº¯n phÃ¹ há»£p cho TTS

**Algorithm**:
```typescript
1. Split by newlines â†’ Filter empty lines
2. Split by periods (.) â†’ Rebuild sentences
3. Handle long lines (>100 chars):
   - Split by ': "' pattern (dialogue)
   - Each part becomes separate sentence
4. Second pass: Split by commas for very long lines (>100 chars)
5. Filter out short lines (<5 chars)
```

**Example**:
```typescript
const summary = `
ChÆ°Æ¡ng nÃ y ká»ƒ vá» cuá»™c gáº·p gá»¡ cá»§a A vÃ  B.
A nÃ³i: "ChÃºng ta pháº£i Ä‘i ngay bÃ¢y giá»".
B Ä‘á»“ng Ã½, há» lÃªn Ä‘Æ°á»ng vÃ o sÃ¡ng hÃ´m sau.
`

breakSummaryIntoLines(summary)
// Output:
// [
//   "ChÆ°Æ¡ng nÃ y ká»ƒ vá» cuá»™c gáº·p gá»¡ cá»§a A vÃ  B.",
//   "A nÃ³i:",
//   '"ChÃºng ta pháº£i Ä‘i ngay bÃ¢y giá»".',
//   "B Ä‘á»“ng Ã½, há» lÃªn Ä‘Æ°á»ng vÃ o sÃ¡ng hÃ´m sau."
// ]
```

---

### 2. **preprocessSentence**

**Má»¥c Ä‘Ã­ch**: Loáº¡i bá» kÃ½ tá»± Ä‘áº·c biá»‡t gÃ¢y lá»—i TTS

```typescript
export const preprocessSentence = (sentence: string): string => {
  return sentence.replace(/["""\\'`\/*<>|~]/g, '')
}
```

**Removed characters**: `" " " ' ' \` / * < > | ~`

---

### 3. **formatContentForTTS**

**Má»¥c Ä‘Ã­ch**: LÃ m sáº¡ch content trÆ°á»›c khi TTS

```typescript
export const formatContentForTTS = (content: string): string => {
  let cleanedText = content
    .split('\n')
    .map(line => removeDotsAndDashesComma(line))  // Remove decorative chars
    .map(line => line.trim())
    .filter(line => line.trim().length > 1)
    .join('\n')
  
  return cleanedText
}
```

---

## âš™ï¸ Settings Dependencies

Há»‡ thá»‘ng phá»¥ thuá»™c vÃ o cÃ¡c settings sau (Ä‘Æ°á»£c lÆ°u trong MMKV):

### Gemini Settings:
```typescript
GEMINI_API_KEY           // Required
GEMINI_MODEL             // Default: 'gemini-2.0-flash-exp'
GEMINI_SUMMARY_PROMPT    // Custom prompt
```

### Capcut TTS Settings:
```typescript
CAPCUT_TOKEN             // Required: Token xÃ¡c thá»±c
CAPCUT_WS_URL            // Required: WebSocket endpoint
```

### App Settings:
```typescript
isSummaryMode            // Toggle Summary Mode (Store state)
```

**Láº¥y settings**:
```typescript
import { MMKVStorage } from '@/controllers/mmkv'
import { MMKVKeys } from '@/constants'

const apiKey = MMKVStorage.get(MMKVKeys.GEMINI_API_KEY)
const model = MMKVStorage.get(MMKVKeys.GEMINI_MODEL)
```

---

## ğŸ› Common Issues & Solutions

### Issue 1: Summary Mode khÃ´ng hoáº¡t Ä‘á»™ng

**Symptoms**: Váº«n hiá»ƒn thá»‹ ná»™i dung gá»‘c dÃ¹ Ä‘Ã£ báº­t Summary Mode

**Debug steps**:
```typescript
// 1. Check store state
const isSummaryMode = useAppStore(s => s.isSummaryMode)
console.log('Summary Mode:', isSummaryMode)

// 2. Check API key
const apiKey = MMKVStorage.get(MMKVKeys.GEMINI_API_KEY)
console.log('Has API Key:', !!apiKey)

// 3. Check useEffect dependencies
// Äáº£m báº£o isSummaryMode trong dependency array
```

**Solutions**:
- Verify `isSummaryMode` state Ä‘Æ°á»£c toggle Ä‘Ãºng
- Check Gemini API key Ä‘Ã£ Ä‘Æ°á»£c set trong Settings
- Xem console log xem cÃ³ error tá»« Gemini API khÃ´ng

---

### Issue 2: TTS khÃ´ng auto-play

**Symptoms**: Audio Ä‘Æ°á»£c táº¡o nhÆ°ng khÃ´ng tá»± phÃ¡t

**Debug steps**:
```typescript
// 1. Check autoPlay flag
const { startGenerateAudio } = useTtsAudio(true)  // â† autoPlay=true?

// 2. Check event listener
DeviceEventEmitter.addListener('tts_audio_ready', (data) => {
  console.log('Audio ready:', data.index)  // Index cÃ³ === 3 khÃ´ng?
})

// 3. Check track player state
import trackPlayerService from '@/services/track-player-service'
const queue = await trackPlayerService.getQueue()
console.log('Queue:', queue.length)
```

**Solutions**:
- Ensure `autoPlay={true}` Ä‘Æ°á»£c pass vÃ o `useTtsAudio`
- Check logic `if (data.index === 3)` - cÃ³ thá»ƒ cáº§n adjust threshold
- Verify track player permissions (iOS background audio)

---

### Issue 3: Cache khÃ´ng Ä‘Æ°á»£c sá»­ dá»¥ng

**Symptoms**: Má»—i láº§n Ä‘á»c láº¡i chapter Ä‘á»u gá»i API má»›i

**Debug steps**:
```typescript
// 1. Check cache key
import { getCachedSummary } from '@/utils/summary-cache'
const cached = getCachedSummary('bookId', 5)
console.log('Cached summary:', cached ? 'EXISTS' : 'NULL')

// 2. Check MMKV storage
import { MMKV } from 'react-native-mmkv'
const summaryCache = new MMKV({ id: 'summary-cache' })
const allKeys = summaryCache.getAllKeys()
console.log('All cache keys:', allKeys)
```

**Solutions**:
- Verify `bookId` vÃ  `chapterNumber` consistent
- Check MMKV encryption key Ä‘Ãºng
- Clear cache vÃ  test láº¡i tá»« Ä‘áº§u

---

### Issue 4: Memory leak khi chuyá»ƒn chapter nhanh

**Symptoms**: App cháº­m dáº§n sau khi Ä‘á»c nhiá»u chapter

**Root cause**: 
- WebSocket connections khÃ´ng Ä‘Æ°á»£c cleanup
- Track player queue tÄƒng liÃªn tá»¥c
- Event listeners khÃ´ng remove

**Solutions**:
```typescript
// 1. Cleanup trong useEffect
useEffect(() => {
  startGenerateAudio(content, bookId, chapter)
  
  return () => {
    stopGenerateAudio()  // â† Quan trá»ng!
  }
}, [chapter, bookId, content])

// 2. Reset track player
await trackPlayerService.reset()  // Clear toÃ n bá»™ queue

// 3. Remove event listeners
const subscription = DeviceEventEmitter.addListener(...)
return () => subscription.remove()
```

---

## ğŸš€ Performance Optimization

### 1. **Lazy Loading**

Chá»‰ load summary khi user thá»±c sá»± vÃ o Summary Mode:
```typescript
if (isSummaryMode) {
  getChapterBySummary(content, chapterNumber)
} else {
  // Just show raw HTML
  setChapter({ content: getChapterHtml(content) })
}
```

### 2. **Parallel Processing**

TTS cÃ³ thá»ƒ xá»­ lÃ½ nhiá»u cÃ¢u cÃ¹ng lÃºc:
```typescript
// âš ï¸ Hiá»‡n táº¡i: Sequential
for (const text of texts) {
  await convertTTSCapcut(text)
}

// âœ… Tá»‘i Æ°u: Parallel (cÃ³ thá»ƒ implement)
await Promise.all(texts.map(text => convertTTSCapcut(text)))
```

**LÆ°u Ã½**: Cáº§n rate limiting Ä‘á»ƒ trÃ¡nh quÃ¡ táº£i API

### 3. **Prefetching**

Táº£i trÆ°á»›c summary cá»§a chapter tiáº¿p theo:
```typescript
// Khi Ä‘á»c chapter 5, prefetch chapter 6
useEffect(() => {
  if (chapterNumber < totalChapters) {
    prefetchSummary(bookId, chapterNumber + 1)
  }
}, [chapterNumber])
```

### 4. **Batch Processing**

Gá»™p nhiá»u request Gemini thÃ nh 1:
```typescript
// Thay vÃ¬:
await summarizeChapter(chapter1Content)
await summarizeChapter(chapter2Content)

// CÃ³ thá»ƒ:
await summarizeMultipleChapters([chapter1Content, chapter2Content])
```

---

## ğŸ“Š Metrics & Monitoring

### Recommended Logging:

```typescript
// 1. Summary performance
console.log('ğŸ“ [Summary] Start:', { bookId, chapter })
console.log('ğŸ“ [Summary] Cached:', isCached)
console.log('ğŸ“ [Summary] Duration:', endTime - startTime, 'ms')

// 2. TTS performance
console.log('ğŸµ [TTS] Start:', { sentences: sentences.length })
console.log('ğŸµ [TTS] Cached files:', cachedCount)
console.log('ğŸµ [TTS] New files:', newCount)
console.log('ğŸµ [TTS] Total duration:', totalTime, 'ms')

// 3. Cache stats
console.log('ğŸ’¾ [Cache] Summary count:', summaryCount)
console.log('ğŸ’¾ [Cache] Audio files:', audioCount)
console.log('ğŸ’¾ [Cache] Total size:', totalSize, 'MB')
```

### Error Tracking:

```typescript
try {
  await summarizeChapter(content)
} catch (error) {
  // Log to analytics service
  analytics.logError('summarize_failed', {
    bookId,
    chapter,
    error: error.message
  })
}
```

---

## ğŸ”® Future Improvements

### 1. **Queue System cho TTS**
- Giá»›i háº¡n sá»‘ lÆ°á»£ng requests Ä‘á»“ng thá»i
- Retry logic khi WebSocket fail
- Priority queue (chapter hiá»‡n táº¡i > prefetch)

### 2. **Smart Cache Cleanup**
- Auto-delete LRU (Least Recently Used) cache
- Set max cache size (vÃ­ dá»¥: 500MB)
- Cleanup orphaned files (MMKV cÃ³ key nhÆ°ng file khÃ´ng tá»“n táº¡i)

### 3. **Offline Fallback**
- Detect khi khÃ´ng cÃ³ internet
- Show cached summary náº¿u cÃ³
- Queue TTS requests Ä‘á»ƒ xá»­ lÃ½ khi online láº¡i

### 4. **Better Error UX**
- Toast thay vÃ¬ Alert (Ã­t intrusive hÆ¡n)
- Retry button trong error state
- Show loading progress cho Gemini API call

### 5. **Customization**
- User cÃ³ thá»ƒ chá»n TTS voice/speed trong Settings
- Custom summary length (ngáº¯n/vá»«a/dÃ i)
- Highlight keywords trong summary

---

## ğŸ“ Code Conventions

### Naming:
- **Hooks**: `use[Feature]` (e.g., `useSummary`, `useTtsAudio`)
- **Services**: `[action][Service]` (e.g., `summarizeChapter`, `convertTTSCapcut`)
- **Cache keys**: `[type]_{bookId}_{chapter}` (e.g., `summary_book123_5`)
- **Events**: `EVENT_[ACTION]_[NOUN]` hoáº·c `[feature]_[event]` (e.g., `EVENT_START_LOADING_CHAPTER`, `tts_audio_ready`)

### File Structure:
```
/hooks        â†’ Custom hooks (logic layer)
/services     â†’ API integrations (external layer)
/utils        â†’ Pure functions (helper layer)
/components   â†’ UI components (view layer)
```

### Error Handling:
```typescript
// âœ… Good: Specific error messages
throw new Error('Thiáº¿u Gemini API Key trong Settings')

// âŒ Bad: Generic errors
throw new Error('Error')
```

### Comments:
```typescript
// âœ… Good: Explain WHY, not WHAT
// Auto-play when index === 3 Ä‘á»ƒ Ä‘áº£m báº£o cÃ³ Ä‘á»§ tracks trong queue

// âŒ Bad: Redundant comments
// Set chapter state
setChapter(...)
```

---

## ğŸ¯ Káº¿t Luáº­n

Há»‡ thá»‘ng Gemini AI + TTS Ä‘Æ°á»£c thiáº¿t káº¿ vá»›i 3 nguyÃªn táº¯c chÃ­nh:

1. **Modular**: Má»—i pháº§n (summary, TTS, cache) hoáº¡t Ä‘á»™ng Ä‘á»™c láº­p
2. **Cache-first**: Æ¯u tiÃªn sá»­ dá»¥ng cache Ä‘á»ƒ giáº£m API calls
3. **Event-driven**: Sá»­ dá»¥ng events Ä‘á»ƒ decouple components

**Äiá»ƒm máº¡nh**:
- âœ… TÃ¡ch biá»‡t concerns rÃµ rÃ ng (hooks, services, utils)
- âœ… Cache hiá»‡u quáº£ vá»›i MMKV + file storage
- âœ… Auto-play UX tá»‘t vá»›i track queueing

**Äiá»ƒm cáº§n cáº£i thiá»‡n**:
- âš ï¸ Memory management (cleanup WebSocket, track player)
- âš ï¸ Error handling chÆ°a comprehensive
- âš ï¸ Thiáº¿u rate limiting cho API calls
- âš ï¸ Cache cleanup chÆ°a tá»± Ä‘á»™ng

**Recommendations**:
1. Implement proper queue system cho TTS
2. Add comprehensive error boundaries
3. Monitor cache size vÃ  cleanup tá»± Ä‘á»™ng
4. Add analytics Ä‘á»ƒ track performance

---

TÃ i liá»‡u nÃ y nÃªn Ä‘Æ°á»£c update khi cÃ³ thay Ä‘á»•i lá»›n vá» architecture hoáº·c thÃªm features má»›i.
